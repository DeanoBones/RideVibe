<html>
<head>
    <title>Tron RideVibe</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100vh; }
        #startButton {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #restartButton {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body>
    <button id="startButton">Start</button>
    <button id="restartButton">Restart</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const gridSize = 100;
        const gridHelper = new THREE.GridHelper(gridSize, 50, 0x00ffff, 0x00ffff);
        scene.add(gridHelper);

        // Bike and trail variables
        const loader = new THREE.GLTFLoader();
        let bikeModel;
        const trailHeight = 1.5;
        const trailWidth = 1.5; // Length of each segment
        const trailDepth = 0.15; // Thickness of the wall
        const initialTrailOffset = 2.5; // Distance behind bike to start trail
        let trailMesh, trailGeometry, trailPositions = [], lastTrailPoint;
        const bikeBoundingBox = new THREE.Box3();

        // Game state
        let gameStarted = false;
        let gameOver = false;
        let lastTime = 0;
        const baseSpeed = 6;

        // Input handling
        const keys = {};
        let turnLeft = false;
        let turnRight = false;
        document.addEventListener('keydown', (event) => {
            if (!keys[event.key]) {
                keys[event.key] = true;
                if (event.key === 'a' || event.key === 'ArrowLeft') turnLeft = true;
                if (event.key === 'd' || event.key === 'ArrowRight') turnRight = true;
            }
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
            if (event.key === 'a' || event.key === 'ArrowLeft') turnLeft = false;
            if (event.key === 'd' || event.key === 'ArrowRight') turnRight = false;
        });

        // Initialize trail
        function initializeTrail(position, rotation, color) {
            const direction = new THREE.Vector3(-Math.sin(rotation), 0, -Math.cos(rotation)).normalize();
            const startPos = position.clone().addScaledVector(direction, -initialTrailOffset);

            trailPositions = [
                startPos.x - trailDepth / 2 * Math.cos(rotation), 0, startPos.z + trailDepth / 2 * Math.sin(rotation), // Bottom left
                startPos.x + trailDepth / 2 * Math.cos(rotation), 0, startPos.z - trailDepth / 2 * Math.sin(rotation), // Bottom right
                startPos.x - trailDepth / 2 * Math.cos(rotation), trailHeight, startPos.z + trailDepth / 2 * Math.sin(rotation), // Top left
                startPos.x + trailDepth / 2 * Math.cos(rotation), trailHeight, startPos.z - trailDepth / 2 * Math.sin(rotation)  // Top right
            ];
            lastTrailPoint = startPos.clone();

            trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
            trailGeometry.setIndex([0, 1, 2, 1, 3, 2]); // Initial front face
            const trailMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                side: THREE.DoubleSide
            });
            trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
            scene.add(trailMesh);
        }

        // Update trail as bike moves
        function updateTrail(position, rotation) {
            const bikePos = position.clone();
            const distance = bikePos.distanceTo(lastTrailPoint);

            if (distance >= trailWidth) {
                const direction = new THREE.Vector3(-Math.sin(rotation), 0, -Math.cos(rotation)).normalize();
                const newPos = lastTrailPoint.clone().addScaledVector(direction, trailWidth);

                trailPositions.push(
                    newPos.x - trailDepth / 2 * Math.cos(rotation), 0, newPos.z + trailDepth / 2 * Math.sin(rotation), // Bottom left
                    newPos.x + trailDepth / 2 * Math.cos(rotation), 0, newPos.z - trailDepth / 2 * Math.sin(rotation), // Bottom right
                    newPos.x - trailDepth / 2 * Math.cos(rotation), trailHeight, newPos.z + trailDepth / 2 * Math.sin(rotation), // Top left
                    newPos.x + trailDepth / 2 * Math.cos(rotation), trailHeight, newPos.z - trailDepth / 2 * Math.sin(rotation)  // Top right
                );

                const indices = [];
                for (let i = 0; i < trailPositions.length / 3 - 4; i += 4) {
                    indices.push(i, i + 1, i + 4, i + 1, i + 5, i + 4); // Front
                    indices.push(i + 2, i + 3, i + 6, i + 3, i + 7, i + 6); // Back
                    indices.push(i, i + 2, i + 4, i + 2, i + 6, i + 4); // Left
                    indices.push(i + 1, i + 3, i + 5, i + 3, i + 7, i + 5); // Right
                    indices.push(i + 2, i + 3, i + 6, i + 3, i + 7, i + 6); // Top
                }
                trailGeometry.setIndex(indices);
                trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
                trailGeometry.computeVertexNormals();
                trailGeometry.attributes.position.needsUpdate = true;

                lastTrailPoint = newPos.clone();
            }
        }

        // Collision detection
        function checkCollisions() {
            if (!bikeModel || !trailMesh || gameOver) return;

            bikeBoundingBox.setFromObject(bikeModel);
            const trailBox = new THREE.Box3().setFromObject(trailMesh);
            if (bikeBoundingBox.intersectsBox(trailBox)) {
                gameOver = true;
                document.getElementById('restartButton').style.display = 'block';
                console.log("Collision! Game Over!");
            }
        }

        // Bike movement
        function updateBike(deltaTime) {
            if (!bikeModel) return;

            const speed = baseSpeed;
            bikeModel.position.z += speed * Math.cos(bikeModel.rotation.y) * deltaTime;
            bikeModel.position.x += speed * Math.sin(bikeModel.rotation.y) * deltaTime;

            if (turnLeft) {
                bikeModel.rotation.y += Math.PI / 2;
                turnLeft = false;
            }
            if (turnRight) {
                bikeModel.rotation.y -= Math.PI / 2;
                turnRight = false;
            }

            updateTrail(bikeModel.position, bikeModel.rotation.y);
        }

        // Start game
        function startGame() {
            gameStarted = true;
            gameOver = false;
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('restartButton').style.display = 'none';

            loader.load('./models/bike/scene.gltf', (gltf) => {
                bikeModel = gltf.scene;
                bikeModel.scale.set(2, 2, 2);
                bikeModel.position.set(0, 0, 0);
                bikeModel.rotation.y = 0;
                bikeModel.traverse(child => {
                    if (child.isMesh) child.material.color.setHex(0x00ffff);
                });
                scene.add(bikeModel);

                initializeTrail(bikeModel.position, bikeModel.rotation.y, 0x00ffff);
                animate(0);
            });
        }

        // Reset game
        function resetGame() {
            if (bikeModel) scene.remove(bikeModel);
            if (trailMesh) scene.remove(trailMesh);
            bikeModel = null;
            trailMesh = null;
            trailGeometry = null;
            trailPositions = [];
            lastTrailPoint = null;
            gameStarted = false;
            gameOver = false;
            lastTime = 0;
            camera.position.set(0, 5, -10);
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('restartButton').style.display = 'none';
        }

        // Animation loop
        function animate(timestamp) {
            if (!gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            requestAnimationFrame(animate);
            const deltaTime = lastTime ? (timestamp - lastTime) / 1000 : 1 / 60;
            lastTime = timestamp;

            if (!gameOver) {
                updateBike(deltaTime);
                checkCollisions();

                camera.position.set(
                    bikeModel.position.x,
                    bikeModel.position.y + 5,
                    bikeModel.position.z - 10
                );
                camera.lookAt(bikeModel.position);
            }

            renderer.render(scene, camera);
        }

        // Event listeners
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', resetGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>