<html>
<head>
    <title>RideVibe - Tron Bike Game</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100vh; }
        #startButton, #colorButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #colorButton { 
            top: 60px; 
            transition: background-color 0.3s;
        }
    </style>
</head>
<body>
    <button id="startButton">Start</button>
    <button id="colorButton">Change Color</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Grid floor
        const gridSize = 100;
        const divisions = 50;
        const gridHelper = new THREE.GridHelper(gridSize, divisions, 0x00ffff, 0x00ffff);
        gridHelper.position.y = -1;
        scene.add(gridHelper);
        const planeGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x001111, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = Math.PI / 2;
        plane.position.y = -1.1;
        scene.add(plane);

        // Bike setup
        const loader = new THREE.GLTFLoader();
        let bikeModel;
        loader.load('./models/bike/scene.gltf', (gltf) => {
            bikeModel = gltf.scene;
            scene.add(bikeModel);
            bikeModel.scale.set(2, 2, 2);
            bikeModel.position.set(0, 0, 0);
            bikeModel.rotation.y = Math.PI; // Rotate 180Â° to face positive Z
        });

        // Trail setup (spline-based)
        const trailPoints = [];
        const maxTrailPoints = 50; // Increased for longer trail
        let trailCurve, trailMesh;
        const trailMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ffff, 
            emissive: 0x00ffff, 
            emissiveIntensity: 0.8 
        });

        function initTrail() {
            trailCurve = new THREE.CatmullRomCurve3(trailPoints);
            const trailGeometry = new THREE.TubeGeometry(trailCurve, 64, 0.15, 8, false);
            trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
            scene.add(trailMesh);
        }

        // Colors
        const colors = [
            { hex: 0x00ffff, name: "Cyan", css: "#00ffff" },
            { hex: 0xff0000, name: "Red", css: "#ff0000" },
            { hex: 0x00ff00, name: "Green", css: "#00ff00" },
            { hex: 0xffff00, name: "Yellow", css: "#ffff00" },
            { hex: 0xff00ff, name: "Magenta", css: "#ff00ff" },
            { hex: 0xffa500, name: "Orange", css: "#ffa500" },
            { hex: 0x800080, name: "Purple", css: "#800080" },
            { hex: 0x0000ff, name: "Blue", css: "#0000ff" },
            { hex: 0xffffff, name: "White", css: "#ffffff" }
        ];
        let currentColorIndex = 0;

        // Camera
        camera.position.set(0, 5, -10);

        // Controls
        const keys = {};
        document.addEventListener('keydown', (event) => keys[event.key] = true);
        document.addEventListener('keyup', (event) => keys[event.key] = false);

        const speed = 0.1;
        const turnSpeed = 0.03;
        let gameOver = false;
        let gameStarted = false;

        // WebSocket setup
        const socket = new WebSocket(`wss://${window.location.host}`);
        let myId;
        const otherPlayers = {};

        socket.onopen = () => console.log('Connected to server');
        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            switch (data.type) {
                case 'init':
                    myId = data.id;
                    for (let id in data.players) {
                        if (id != myId) addOtherPlayer(data.players[id]);
                    }
                    break;
                case 'newPlayer':
                    addOtherPlayer(data.player);
                    break;
                case 'update':
                    updateOtherPlayer(data.player);
                    break;
                case 'removePlayer':
                    removeOtherPlayer(data.id);
                    break;
            }
        };

        function addOtherPlayer(player) {
            loader.load('./models/bike/scene.gltf', (gltf) => {
                const otherBike = gltf.scene;
                otherBike.scale.set(2, 2, 2);
                otherBike.rotation.y = Math.PI; // Match player bike orientation
                scene.add(otherBike);
                const otherTrailCurve = new THREE.CatmullRomCurve3([]);
                const otherTrailGeometry = new THREE.TubeGeometry(otherTrailCurve, 64, 0.15, 8, false);
                const otherTrailMaterial = new THREE.MeshPhongMaterial({ 
                    color: player.color, 
                    emissive: player.color, 
                    emissiveIntensity: 0.8 
                });
                const otherTrailMesh = new THREE.Mesh(otherTrailGeometry, otherTrailMaterial);
                scene.add(otherTrailMesh);
                otherPlayers[player.id] = {
                    model: otherBike,
                    trailPoints: [],
                    trailCurve: otherTrailCurve,
                    trailMesh: otherTrailMesh,
                    trailMaterial: otherTrailMaterial
                };
                updateOtherPlayer(player);
            });
        }

        function updateOtherPlayer(player) {
            if (otherPlayers[player.id]) {
                const other = otherPlayers[player.id];
                other.model.position.set(player.position.x, player.position.y, player.position.z);
                other.model.rotation.y = player.rotation;

                if (player.trail.length > other.trailPoints.length) {
                    other.trailPoints = player.trail.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    other.trailCurve.points = other.trailPoints;
                    other.trailMesh.geometry.dispose();
                    other.trailMesh.geometry = new THREE.TubeGeometry(other.trailCurve, 64, 0.15, 8, false);
                }
                other.trailMaterial.color.setHex(player.color);
                other.trailMaterial.emissive.setHex(player.color);
            }
        }

        function removeOtherPlayer(id) {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id].model);
                scene.remove(otherPlayers[id].trailMesh);
                delete otherPlayers[id];
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Collision check
        function checkCollision(bikePos) {
            const bikeRadius = 0.1;
            const safeZone = 2;
            for (let [index, points] of [trailPoints, ...Object.values(otherPlayers).map(p => p.trailPoints)].entries()) {
                const isOwnTrail = index === 0;
                for (let i = 0; i < points.length; i++) {
                    if (isOwnTrail && i < safeZone) continue;
                    const point = points[i];
                    const dx = bikePos.x - point.x;
                    const dz = bikePos.z - point.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    if (distance < bikeRadius + 0.15) return true;
                }
            }
            return false;
        }

        // Boundary check
        function checkBoundaries(bikePos) {
            const halfGrid = gridSize / 2;
            return bikePos.x < -halfGrid || bikePos.x > halfGrid || bikePos.z < -halfGrid || bikePos.z > halfGrid;
        }

        // Buttons
        const startButton = document.getElementById('startButton');
        const colorButton = document.getElementById('colorButton');
        startButton.addEventListener('click', () => {
            gameStarted = true;
            startButton.style.display = 'none';
            colorButton.style.display = 'none';
            animate();
        });

        function updateColorButton() {
            const currentColor = colors[currentColorIndex];
            colorButton.style.backgroundColor = currentColor.css;
            colorButton.style.color = "#000000";
        }
        updateColorButton();

        colorButton.addEventListener('click', () => {
            currentColorIndex = (currentColorIndex + 1) % colors.length;
            const newColor = colors[currentColorIndex];
            trailMaterial.color.setHex(newColor.hex);
            trailMaterial.emissive.setHex(newColor.hex);
            if (trailMesh) {
                trailMesh.material.color.setHex(newColor.hex);
                trailMesh.material.emissive.setHex(newColor.hex);
            }
            if (bikeModel) {
                bikeModel.traverse(child => {
                    if (child.isMesh && child.material) child.material.color.setHex(newColor.hex);
                });
            }
            updateColorButton();
        });

        // Animation loop
        function animate() {
            if (!gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            requestAnimationFrame(animate);

            if (bikeModel && !gameOver) {
                bikeModel.position.z += speed * Math.cos(bikeModel.rotation.y);
                bikeModel.position.x += speed * Math.sin(bikeModel.rotation.y);

                if (keys['a'] || keys['ArrowLeft']) bikeModel.rotation.y += turnSpeed;
                if (keys['d'] || keys['ArrowRight']) bikeModel.rotation.y -= turnSpeed;

                // Add spline point (offset forward if model faces -Z)
                const offset = new THREE.Vector3(
                    speed * Math.sin(bikeModel.rotation.y), // Positive to match -Z forward
                    0,
                    speed * Math.cos(bikeModel.rotation.y)
                ).multiplyScalar(50); // Back to 5 for balance
                const newPoint = bikeModel.position.clone().sub(offset); // Still subtract to place behind
                newPoint.y = 0.5;
                if (trailPoints.length === 0 || bikeModel.position.distanceTo(trailPoints[trailPoints.length - 1]) > 0.3) { // Reduced to 0.3 for denser points
                    trailPoints.push(newPoint);
                    if (trailPoints.length > maxTrailPoints) trailPoints.shift();

                    if (!trailMesh) initTrail();
                    trailCurve.points = trailPoints;
                    trailMesh.geometry.dispose();
                    trailMesh.geometry = new THREE.TubeGeometry(trailCurve, 64, 0.15, 8, false);
                }

                if (checkCollision(bikeModel.position)) {
                    gameOver = true;
                    console.log("Game Over! Crashed into a trail.");
                    alert("Game Over! Refresh to restart.");
                } else if (checkBoundaries(bikeModel.position)) {
                    gameOver = true;
                    console.log("Game Over! Out of bounds.");
                    alert("Game Over! Refresh to restart.");
                }

                // Send update to server
                socket.send(JSON.stringify({
                    type: 'update',
                    position: bikeModel.position,
                    rotation: bikeModel.rotation.y,
                    trail: trailPoints,
                    color: colors[currentColorIndex].hex
                }));

                // Camera follow
                const offsetCam = new THREE.Vector3(0, 5, -10);
                const cameraPosition = bikeModel.position.clone().add(offsetCam.applyQuaternion(bikeModel.quaternion));
                camera.position.lerp(cameraPosition, 0.1);
                camera.lookAt(bikeModel.position);
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>